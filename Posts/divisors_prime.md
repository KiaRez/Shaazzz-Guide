### تعداد مقسوم‌علیه‌های یک عدد و تشخیص اول بودن در ++C

---

### تعریف

**مقسوم‌علیه‌های یک عدد** اعدادی هستند که آن عدد بر آن‌ها بخش‌پذیر باشد.  
برای مثال:

* مقسوم‌علیه‌های $12$ عبارت‌اند از: $1, 2, 3, 4, 6, 12$ → تعداد = $6$  

**عدد اول (Prime)** عددی بزرگ‌تر از ۱ است که دقیقا دو مقسوم‌علیه دارد:  
$$
\{1, n\}
$$

---

### مسئله

می‌خواهیم در ++C دو تابع بنویسیم:  

1. محاسبه‌ی تعداد مقسوم‌علیه‌های یک عدد $n$  
2. تشخیص اینکه $n$ عدد اول است یا خیر  

---

### روش ساده (ناکارآمد برای اعداد بزرگ)

برای محاسبه‌ی مقسوم‌علیه‌ها می‌توانیم از $1$ تا $n$ پیمایش کنیم و بررسی کنیم که آیا $n \bmod i = 0$ است یا نه.  
پیچیدگی زمانی این روش:  

$$
O(n)
$$

برای $n$های بزرگ (مثلاً $10^9$) این روش بسیار کند است.

---

### روش بهینه‌تر (بر اساس ریشه دوم)

مشاهده: اگر $d$ یک مقسوم‌علیه $n$ باشد، آنگاه $\dfrac{n}{d}$ هم یک مقسوم‌علیه است.  
بنابراین کافی است فقط تا $\sqrt{n}$ پیمایش کنیم.  

* اگر $i \mid n$ باشد:
  * اگر $i = n/i$ → فقط یک مقسوم‌علیه حساب می‌شود.  
  * در غیر این صورت هر دو را می‌شماریم.  

پیچیدگی زمانی:  

$$
O(\sqrt{n})
$$

---

### کد محاسبه تعداد مقسوم‌علیه‌ها

```cpp linenums="1"
int countDivisors(int n) {
    int cnt = 0;
    for (int i = 1; i * i <= n; i++) {
        if (n % i == 0) {
            if (i * i == n) cnt++; 
            else cnt += 2; 
        }
    }
    return cnt;
}
```

---

### کد تشخیص اول بودن

ایده: عدد اول باید دقیقا ۲ مقسوم‌علیه داشته باشد.  
پس می‌توانیم مستقیما از تابع بالا استفاده کنیم یا جداگانه بررسی کنیم.  

```cpp linenums="1"
bool isPrime(int n) {
    if (n < 2) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}
```

---

### تست برنامه

```cpp linenums="1"
#include <bits/stdc++.h>
using namespace std;

int countDivisors(int n) {
    int cnt = 0;
    for (int i = 1; i * i <= n; i++) {
        if (n % i == 0) {
            if (i * i == n) cnt++;
            else cnt += 2;
        }
    }
    return cnt;
}

bool isPrime(int n) {
    if (n < 2) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n = 28;
    cout << ":تعداد مقسوم علیه ها " 
         << countDivisors(n) << "\n";

    cout << (isPrime(n) ? 1 : 0) << "\n";
}
```

---

### خروجی نمونه

برای $n = 28$:

```
تعداد مقسوم علیه ها: 6
0
```

---

### نکات مهم

* برای $n = 1$ → فقط یک مقسوم‌علیه دارد و **اول نیست**.  
* روش $\sqrt{n}$ برای اعداد تا حدود $10^{12}$ کاملاً مناسب است.  
* برای اعداد بسیار بزرگ (مثلاً $10^{18}$) نیاز به الگوریتم‌های پیشرفته‌تری مثل Miller-Rabin برای اول بودن داریم.  

---

### منابع بیشتر

* [CP Algorithms – Primality Tests](https://cp-algorithms.com/algebra/primality_tests.html)  
* [Divisor function](https://en.wikipedia.org/wiki/Divisor_function)  
