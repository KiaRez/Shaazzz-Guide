### مرج سرت

مرج سرت یا مرتب سازی ادغامی، یک روش برای سرت کردن است که به نسبت روش‌های قبلی زمان اجرای بهتری دارد و از اردر $O(n log_n)$ تایم و $O(n)$ مموری قابل پیاده‌سازی است. این سرت به صورت بازگشتی هست و از تریک Divide & Conquer استفاده می‌کند. 

#### الگوریتم

می‌خواهیم تابع 
`#!cpp void merge_sort(int *A, int l, int r)`
 را پیاده سازی کنیم که بازه‌ی $[l, r)$ از آرایه $A$ را سرت کند. $(2 \leq r - l)$ ابتدا آرایه را به دوبخش به طول های $\lfloor \frac{r - l}{2} \rfloor$ و $\lceil \frac{r - l}{2} \rceil$ تقسیم می‌کنیم و به صورت بازگشتی سرت می‌کنیم. سپس دو بخش سرت شده را ادغام می‌کنیم. (دو بخش $[l, \lfloor \frac{r - l}{2} \rfloor)$ و $[\lfloor \frac{r - l}{2} \rfloor, r)$) می‌خواهیم آرایه‌ی ادغام شده را در آرایه‌ی  $r - l$ عضوی $B$ بریزیم.

برای این‌ کار، دو پوینتر در نظر می‌گیریم که در ابتدا یکی روی عضو اول بخش اول و دیگری روی عضو اول بخش دوم قرار دارد. تا زمانی که هر دو پوینتر درون بخش ها هستند، از بین دو عضوی که پوینتر ها در حال اشاره کردن به آن‌ها هستند،‌ عضو کوچک تر را در انتهای آرایه $B$ قرار می‌دهیم (اگر هر دو عضو برابر بودند، به دلخواه یکی را می‌گذاریم) و آن پوینتر را جلو می‌بریم. اگر یکی از پوینتر ها از بخش خودش خارج شد (به عبارتی اگر تمام اعضای آن بخش را در آرایه‌ی $B$ قرار داده بودیم) در آن صورت به ترتیب اعضای بخش دیگر را از جایگاه فعلی پوینترش تا آخر در آرایه‌ی $B$ قرار می‌دهیم. در آخر به ترتیب مقادیر $B$ را در $A_l \dots A_{r - 1}$ قرار می‌دهیم و آرایه‌ی $B$ را پاک می‌کنیم.

??? success "اثبات درستی الگوریتم"

    استقرای قوی می‌زنیم روی مقدار $r - l$ و به کمک آن ثابت می‌کنیم الگوریتم درست است. 

    پایه: $r - l = 1$ ،‌ اگر طول بازه‌ای که می‌خواهیم سرت کنیم برابر با ۱ باشد، بازه سرت شده است و نیازی به تغییر ندارد.

    فرض کنید به ازای تمام مقادیر کمتر از $r - l$ الگوریتم درست باشد،‌ برای این مقدار ثابت می‌کنیم.

    طبق فرض استقرا دو بخشی که به صورت بازگشتی سرت می‌شوند به درستی سرت خواهند شد. در بخش مرج شدن، به کمک برهان خلف ثابت می‌کنیم الگوریتم درست است. فرض کنید در انتها دو اندیس ‌$i$ و $j$ وجود داشته باشند به طوری‌که $i < j$ و $B_i > B_j$. قطعا این دو عضو از یک بخش نبودند،‌زیرا هر بخش بین خودش سرت شده بود. بدون از دست دادن کلیت مسئله فرض می‌کنیم عضو $i$ از بخش اول بوده‌است. زمانی که ما این عضو را در آرایه‌ی $B$ گذاشتیم، پوینتر بخش دوم قطعا از بخشش خارج نشده بود و صرفا به عضوی بیشتر مساوی عضو نشان داده شده در بخش اول، اشاره داشت. (فرض کنید این مقدار از بخش دوم $w$ باشد) همچنین قطعا پوینتر بخش دوم از عضوی که در $B_j$ قرار داده شده‌است، نگذشته بود. و چون بخش دوم بین خودش سرت شده است: 

    $$B_i \leq w, \ w \leq B_j \Longrightarrow B_i \leq B_j$$

    که با فرض ما در تناقض است و در نتیجه الگوریتم درست کار می‌کند.


#### پیچیدگی زمانی

اگر $T(n)$، زمان مورد نیاز برای حل مسئله در آرایه به طول $n$ باشد،‌ داریم:

$$T(1) = O(1)$$

$$T(n) = 2 \times T(\frac{n}{2}) + O(n)$$

اگر تابع بازگشتی را به شکل یک درخت ببینیم، که ریشه‌ی درخت نماینده تابع مرج سرت برای $[0, n)$ باشد و بچه‌ی راس $[l, r)$، دو تابعی بشود که توسط این راس صدا شده است، می‌توان دید مجموع طول بازه‌های راس‌های یک طبقه، کمتر مساوی $n$ است. این درخت از $O(log_n)$ طبقه دارد. (زیرا در هر مرحله اگر طول بازه $len$ باشد، در بدترین حالت، به $\lceil \frac{len}{2} \rceil$ تبدیل می‌شود. و فقط تا زمانی که به ۱ برسد ادامه دارد، پس می‌شود $log_n + O(1)$) هر طبقه از $O(n)$ هزینه می‌دهد. پس در کل الگوریتم ما از $O(n log_n)$ اجرا می‌شود. حتی می‌توان ثابت کرد الگوریتم مرج سرت از $\Theta(n log_n)$ هم هست.


<figure markdown>
  ![image.png](https://i.postimg.cc/qRCWtMn6/image.png)
  <figcaption>درخت توابع مرج سرت</figcaption>
</figure>


#### کد

``` cpp linenums="1"

int B[maxn], A[maxn];

void merge_sort(int *A, int l, int r){
    if(r - l == 1) // (1)!
        return;
    int mid = (l + r) >> 1;
    merge_sort(A, l, mid);
    merge_sort(A, mid, r);
    int pt1 = l, pt2 = mid, ptB = 0;
    while(pt1 < mid || pt2 < r){ // (2)!
        if(pt1 < mid && (pt2 == r || A[pt1] < A[pt2])) // (3)!
            B[ptB++] = A[pt1++];
        else
            B[ptB++] = A[pt2++];
    }
    for(int i = r - 1; i >= l; i--)
        A[i] = B[--ptB];
}
```

1.	در صورتی که طول بازه‌ی مد نظر برای سرت کردن،‌ ۱ باشد، بدون هیچ تغییری خارج می‌شود.

2.	تا زمانی که هنوز تمام $r - l$ عضو را ندیده‌ایم ادامه می‌دهد.

3.	در این قسمت، اگر یکی از بخش ها تمام شده باشند، قطعا یک عضو از بخش دیگر برداشته خواهد شد. در غیر این صورت اگر عضو بخش اول کوچک‌تر از بخش دوم باشد، عضو بخش اول قرار داده می‌شود و در غیر این صورت از بخش دوم بر‌ می‌دارد.

!!! warning ""

    کد و الگوریتم بالا به توضیح چگونگی سرت کردن یک آرایه از 
    `#!cpp int`
    پرداخته بود. اما به سادگی می‌توان دید به ازای هر آرایه از جنس متغییرهایی که قابل مقایسه باشند، الگوریتم درست و امکان پذیر است.

#### مسئله‌ی نابه‌جایی‌ها

یک آرایه $n$ ($n \leq 10^6$) عضوی از اعداد داریم. تعداد نابه‌جایی‌های این آرایه را بیابید.


??? question "نابه‌جایی چیست؟"

	نابه‌جایی (Inversion) در آرایه $A$، یک پیر از اندیس‌هایی مانند $i$ و $j$ است به صورتی که $i < j$ و $A_i > A_j$ باشد.


??? success "راه حل"

	برای حل این مسئله از تکنیک تقسیم و حل و الگوریتم مرج سرت استفاده می‌کنیم. فرض کنید در طی الگوریتم مرج سرت به صورت بازگشتی، تعداد نابه‌جایی‌های درون بخش اول و درون بخش دوم را بدست آورده‌ایم، تعداد نابه‌جایی‌های بین بخش اول و دوم را می‌خواهیم. الگوریتم مرج را در نظر بگیرید، فرض کنید اگر عضوی از بخش اول که به آن اشاره شده‌است مساوی با عضو از بخش دوم بود، عضو بخش اول را در $B$ قرار خواهیم داد. زمانی که یک عضو را از بخش اول در آرایه‌ی $B$ قرار می‌دهیم، این عضو از تمام اعضایی که در $B$ هستند و از بخش دوم بودند اکیدا بزرگ‌تر بوده و با آن‌ها نابه‌جایی می‌سازد. تعداد این اعضا برابر است با $pt2 - mid$ که $pt2$ پوینتر مربوط به بخش دوم است و $mid = \lfloor \frac{r - l}{2} \rfloor$ است. (بخش دوم از $mid$ شروع شده‌است) الگوریتم ما دقیقا مشابه تحلیل اردر مرج سرت، از $O(n log_n)$ هزینه می‌برد که مطلوب است.
